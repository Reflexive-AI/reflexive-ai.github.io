---
---

<div id="lattice-container" class="lattice-container">
  <canvas id="lattice-canvas"></canvas>
  
  <div id="lattice-ui" class="lattice-ui">
    <div class="search-bar">
      <input type="text" id="node-search" placeholder="Search the neural network..." />
    </div>
    
    <div id="node-card" class="node-card hidden">
      <h2 id="card-title">Article Title</h2>
      <div class="card-meta">
        <span id="card-group" class="badge">Category</span>
        <span id="card-heat" class="heat-indicator"></span>
      </div>
      <p id="card-excerpt">Article excerpt goes here...</p>
      <a id="card-link" href="#" class="btn-read">Access Node -></a>
    </div>

    <div class="controls">
      <button id="reset-view" aria-label="Reset View">‚ü≤</button>
    </div>
  </div>
  
  <div id="loading-overlay" class="loading-overlay">
    <div class="loader">Initializing Neural Lattice...</div>
  </div>
</div>

<style>
  .lattice-container {
    position: relative;
    width: 100%;
    height: 100vh;
    background: #050510; /* Deep void color */
    overflow: hidden;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: grab;
  }
  canvas:active {
    cursor: grabbing;
  }

  .lattice-ui {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  /* Search Bar */
  .search-bar {
    position: absolute;
    top: 2rem;
    left: 2rem;
    pointer-events: auto;
  }
  
  .search-bar input {
    background: rgba(20, 20, 35, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #fff;
    padding: 0.8rem 1.2rem;
    border-radius: 2rem;
    width: 300px;
    backdrop-filter: blur(10px);
    font-family: 'Inter', sans-serif;
    transition: all 0.3s ease;
  }
  
  .search-bar input:focus {
    border-color: var(--color-primary);
    box-shadow: 0 0 15px rgba(var(--color-primary-rgb), 0.3);
    outline: none;
  }

  /* Node Card */
  .node-card {
    position: absolute;
    bottom: 2rem;
    right: 2rem;
    width: 350px;
    background: rgba(10, 10, 20, 0.85);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 1.5rem;
    border-radius: 1rem;
    color: #fff;
    pointer-events: auto;
    transition: opacity 0.3s ease, transform 0.3s ease;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
  }

  .node-card.hidden {
    opacity: 0;
    transform: translateY(20px);
    pointer-events: none;
  }

  .node-card h2 {
    margin: 0 0 0.5rem 0;
    font-size: 1.25rem;
    font-weight: 600;
    background: linear-gradient(90deg, #fff, #aaa);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .card-meta {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .badge {
    font-size: 0.75rem;
    padding: 0.2rem 0.6rem;
    border-radius: 1rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    background: rgba(255, 255, 255, 0.1);
  }
  
  .badge.governance { background: rgba(0, 255, 200, 0.2); color: #00ffc8; }
  .badge.technical { background: rgba(180, 100, 255, 0.2); color: #b464ff; }
  .badge.research { background: rgba(100, 150, 255, 0.2); color: #6496ff; }
  .badge.ghost { background: src,rgba(255, 255, 255, 0.1); color: #aaa; border: 1px dashed #555; }

  .heat-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #555;
  }
  .heat-indicator.hot {
    background: #ff4444;
    box-shadow: 0 0 8px #ff4444;
    animation: pulse 2s infinite;
  }

  .node-card p {
    font-size: 0.9rem;
    line-height: 1.5;
    color: #ddd;
    margin-bottom: 1.5rem;
  }

  .btn-read {
    display: inline-block;
    padding: 0.6rem 1.2rem;
    background: #fff;
    color: #000;
    text-decoration: none;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    font-weight: 600;
    transition: transform 0.2s;
  }
  .btn-read:hover {
    transform: scale(1.05);
  }

  /* Controls */
  .controls {
    position: absolute;
    bottom: 2rem;
    left: 2rem;
    pointer-events: auto;
  }
  .controls button {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    font-size: 1.2rem;
    cursor: pointer;
    backdrop-filter: blur(5px);
    transition: all 0.2s;
  }
  .controls button:hover {
    background: rgba(255,255,255,0.2);
    transform: rotate(90deg);
  }

  /* Loader */
  .loading-overlay {
    position: absolute;
    inset: 0;
    background: #050510;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20;
    transition: opacity 0.5s ease;
  }
  .loading-overlay.fade-out {
    opacity: 0;
    pointer-events: none;
  }
  .loader {
    color: #fff;
    font-family: monospace;
    font-size: 1.2rem;
    animation: blink 1s infinite;
  }

  @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
</style>

<script>
  import * as d3 from 'd3';

  // Configuration
  const CONFIG = {
    colors: {
      governance: '#00ffc8', // Cyan
      technical: '#b464ff',  // Purple
      research: '#6496ff',   // Blue
      ghost: '#555555',      // Grey
      text: '#ffffff'
    },
    particleSpeed: 0.015,
    minZoom: 0.1,
    maxZoom: 4
  };

  async function initLattice() {
    const response = await fetch('/lattice.json');
    if (!response.ok) {
      console.error('Failed to load lattice data');
      return;
    }
    const data = await response.json();
    
    // Canvas Setup
    const container = document.getElementById('lattice-container');
    const canvas = document.getElementById('lattice-canvas');
    const ctx = canvas.getContext('2d');
    const ui = {
      card: document.getElementById('node-card'),
      title: document.getElementById('card-title'),
      group: document.getElementById('card-group'),
      heat: document.getElementById('card-heat'),
      excerpt: document.getElementById('card-excerpt'),
      link: document.getElementById('card-link'),
      loader: document.getElementById('loading-overlay'),
      input: document.getElementById('node-search')
    };

    let width = container.clientWidth;
    let height = container.clientHeight;
    
    // High DPI scaling
    function resize() {
      width = container.clientWidth;
      height = container.clientHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', () => {
      resize();
      simulation.alpha(0.3).restart(); // Re-warm simulation on resize
    });
    resize();

    // Simulation Setup
    const nodes = data.nodes.map(d => ({...d}));
    const links = data.links.map(d => ({...d}));

    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id(d => d.id).distance(100))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collide', d3.forceCollide().radius(d => d.val * 3 + 10).iterations(2));

    // View Transform
    let transform = d3.zoomIdentity;
    let hoverNode = null;
    let activeNode = null;

    // Zoom/Pan
    const zoom = d3.zoom()
      .scaleExtent([CONFIG.minZoom, CONFIG.maxZoom])
      .on('zoom', (event) => {
        transform = event.transform;
        render();
      });
    d3.select(canvas).call(zoom);

    // Initial Zoom Out Effect
    d3.select(canvas)
      .call(zoom.transform, d3.zoomIdentity.translate(width/2, height/2).scale(0.1))
      .transition().duration(2000).ease(d3.easeCubicOut)
      .call(zoom.transform, d3.zoomIdentity);

    setTimeout(() => {
      ui.loader.classList.add('fade-out');
    }, 1500);

    // Render Loop
    function render() {
      ctx.clearRect(0, 0, width, height);
      ctx.save();
      ctx.translate(transform.x, transform.y);
      ctx.scale(transform.k, transform.k);

      // Draw Links
      links.forEach(link => {
        ctx.beginPath();
        ctx.moveTo(link.source.x, link.source.y);
        ctx.lineTo(link.target.x, link.target.y);
        ctx.strokeStyle = `rgba(255, 255, 255, ${link.value > 1 ? 0.15 : 0.05})`;
        ctx.lineWidth = link.value;
        ctx.stroke();
      });

      // Draw Nodes
      nodes.forEach(node => {
        const isHovered = hoverNode === node;
        const isActive = activeNode === node;
        const color = CONFIG.colors[node.group] || CONFIG.colors.research;
        
        // Glow
        if (node.heat > 0.8 || isHovered || isActive) {
          const glowRadius = (node.val * 2) + (isHovered ? 15 : 5);
          const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowRadius);
          gradient.addColorStop(0, hexToRgba(color, 0.4));
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.beginPath();
          ctx.arc(node.x, node.y, glowRadius, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();
        }

        // Inner Circle
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.val, 0, Math.PI * 2);
        ctx.fillStyle = node.group === 'ghost' ? 'rgba(0,0,0,0)' : '#050510';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        if (node.group === 'ghost') {
          ctx.setLineDash([2, 4]); // Dashed for ghost nodes
        } else {
          ctx.setLineDash([]);
          ctx.fillStyle = hexToRgba(color, 0.1);
          ctx.fill();
        }
        
        ctx.stroke();

        // Label (only if large enough or hovered)
        if (transform.k > 1.2 || isHovered || node.val > 15 || isActive) {
          ctx.fillStyle = '#fff';
          ctx.font = `${isHovered ? 'bold ' : ''}10px Inter`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(node.title, node.x, node.y + node.val + 5);
        }
      });

      ctx.restore();
    }

    // Interactive Loop
    d3.timer(() => {
      // Synaptic Pulses (simple particle effect idea for update)
      render();
    });

    // Interaction Handling
    function findNode(x, y) {
      // Inverse transform point
      const tx = (x - transform.x) / transform.k;
      const ty = (y - transform.y) / transform.k;
      
      let closest = null;
      let minDist = Infinity;
      
      nodes.forEach(node => {
        const dx = tx - node.x;
        const dy = ty - node.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < node.val + 5 && dist < minDist) { // Hitbox slightly larger
          closest = node;
          minDist = dist;
        }
      });
      
      return closest;
    }

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const node = findNode(e.clientX - rect.left, e.clientY - rect.top);
      
      if (node !== hoverNode) {
        hoverNode = node;
        canvas.style.cursor = node ? 'pointer' : (d3.event?.active ? 'grabbing' : 'grab');
        render(); // Re-render immediately on hover change
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const node = findNode(e.clientX - rect.left, e.clientY - rect.top);
      
      if (node) {
        activeNode = node;
        showCard(node);
        
        // Fly to node
        d3.select(canvas).transition().duration(750)
          .call(zoom.transform, d3.zoomIdentity.translate(width/2 - node.x * 2, height/2 - node.y * 2).scale(2));
      } else {
        activeNode = null;
        hideCard();
      }
    });
    
    // Dragging
    const drag = d3.drag()
      .subject((event) => findNode(event.sourceEvent.offsetX, event.sourceEvent.offsetY))
      .on('start', (event) => {
        if (!event.subject) return;
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      })
      .on('drag', (event) => {
        if (!event.subject) return;
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      })
      .on('end', (event) => {
        if (!event.subject) return;
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      });
      
    d3.select(canvas).call(drag);

    // Search Handling
    ui.input.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      if (term.length < 2) return;
      
      const match = nodes.find(n => n.title.toLowerCase().includes(term));
      if (match) {
        activeNode = match;
        d3.select(canvas).transition().duration(750)
          .call(zoom.transform, d3.zoomIdentity.translate(width/2 - match.x * 2, height/2 - match.y * 2).scale(2));
        showCard(match);
      }
    });

    document.getElementById('reset-view').addEventListener('click', () => {
      d3.select(canvas).transition().duration(750)
        .call(zoom.transform, d3.zoomIdentity.translate(width/2, height/2).scale(0.5));
      activeNode = null;
      hideCard();
    });

    function showCard(node) {
      ui.title.innerText = node.title;
      ui.excerpt.innerText = node.excerpt;
      
      // Update badge
      ui.group.innerText = node.group;
      ui.group.className = `badge ${node.group}`;
      
      // Update heat
      ui.heat.className = `heat-indicator ${node.heat > 0.8 ? 'hot' : ''}`;
      
      // Link
      if (node.group === 'ghost') {
        ui.link.style.display = 'none';
      } else {
        ui.link.style.display = 'inline-block';
        ui.link.getAttribute('href'); // Clear previous
        ui.link.setAttribute('href', node.slug);
      }

      ui.card.classList.remove('hidden');
    }

    function hideCard() {
      ui.card.classList.add('hidden');
    }

    // Utility
    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
  }

  // Init once built
  initLattice();
</script>
