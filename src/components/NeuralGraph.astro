---
---

<div id="lattice-container" class="lattice-container">
  <canvas id="lattice-canvas"></canvas>
  
  <div id="lattice-ui" class="lattice-ui">
    <div class="search-bar">
      <input type="text" id="node-search" placeholder="Search concepts..." />
    </div>
    
    <div id="node-card" class="node-card hidden">
      <div class="card-header">
        <h2 id="card-title">Concept Name</h2>
        <span id="card-count" class="badge">0 Articles</span>
      </div>
      
      <div class="articles-list" id="articles-list">
        <!-- Articles injected here -->
      </div>
    </div>
  </div>
  
  <div id="loading-overlay" class="loading-overlay">
    <div class="loader">Loading Concept Map...</div>
  </div>
</div>

<style>
  .lattice-container {
    position: relative;
    width: 100%;
    height: 100vh;
    background: #ffffff; /* Light Mode */
    overflow: hidden;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: grab;
  }
  canvas:active {
    cursor: grabbing;
  }

  .lattice-ui {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  /* Search Bar */
  .search-bar {
    position: absolute;
    top: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    pointer-events: auto;
    z-index: 15;
  }
  
  .search-bar input {
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.1);
    color: #333;
    padding: 0.75rem 1.25rem;
    border-radius: 2rem;
    width: 320px;
    backdrop-filter: blur(10px);
    font-family: 'Inter', sans-serif;
    font-size: 0.9rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    transition: all 0.3s ease;
    text-align: center;
  }
  
  .search-bar input::placeholder {
    text-align: center;
  }
  
  .search-bar input:focus {
    border-color: var(--color-primary);
    box-shadow: 0 4px 15px rgba(0,0,0,0.12);
    outline: none;
    width: 360px;
    text-align: left;
  }
  
  .search-bar input:focus::placeholder {
    text-align: left;
  }

  @media (max-width: 640px) {
    .search-bar {
      top: 1rem;
      left: 1rem;
      right: 1rem;
      transform: none;
    }
    
    .search-bar input {
      width: 100%;
      padding: 0.6rem 0.9rem;
      font-size: 0.85rem;
    }
    
    .search-bar input:focus {
      width: 100%;
    }
  }

  /* Node Card (Concept Details) */
  .node-card {
    position: absolute;
    bottom: 2rem;
    right: 2rem;
    width: 350px;
    max-height: 60vh;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    border-radius: 1rem;
    color: #333;
    pointer-events: auto;
    transition: opacity 0.3s ease, transform 0.3s ease;
    box-shadow: 0 10px 40px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
  }

  .node-card.hidden {
    opacity: 0;
    transform: translateY(20px);
    pointer-events: none;
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid rgba(0,0,0,0.05);
  }

  .node-card h2 {
    margin: 0;
    font-size: 1.25rem;
    font-weight: 700;
    color: #111;
    text-transform: capitalize;
  }

  .badge {
    font-size: 0.75rem;
    padding: 0.2rem 0.6rem;
    border-radius: 1rem;
    background: #f3f4f6;
    color: #666;
    font-weight: 500;
  }

  .articles-list {
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 0.8rem;
  }

  .article-link {
    display: block;
    text-decoration: none;
    color: inherit;
    padding: 0.8rem;
    background: #f9fafb;
    border-radius: 0.5rem;
    transition: background 0.2s;
  }
  .article-link:hover {
    background: #f3f4f6;
  }
  
  .article-link h3 {
    margin: 0 0 0.3rem 0;
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--color-primary);
  }
  
  .article-link p {
    margin: 0;
    font-size: 0.8rem;
    color: #666;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  @media (max-width: 640px) {
    .node-card {
      bottom: 1rem;
      right: 1rem;
      left: 1rem;
      width: auto;
      max-height: 50vh;
    }
  }

  /* Loader */
  .loading-overlay {
    position: absolute;
    inset: 0;
    background: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20;
    transition: opacity 0.5s ease;
  }
  .loading-overlay.fade-out {
    opacity: 0;
    pointer-events: none;
  }
  .loader {
    color: #333;
    font-family: monospace;
    font-size: 1.2rem;
    animation: blink 1s infinite;
  }

  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
</style>

<script>
  import * as d3 from 'd3';

  // Configuration (Light Theme)
  const CONFIG = {
    colors: {
      governance: '#3b82f6', // Bright Blue
      technical: '#8b5cf6',  // Violet
      concept: '#64748b',    // Slate Grey (Default)
      text: '#1e293b'        // Dark Slate
    },
    minZoom: 0.5,
    maxZoom: 4
  };

  async function initLattice() {
    const response = await fetch('/graph.json');
    if (!response.ok) {
      console.error('Failed to load graph data');
      return;
    }
    const data = await response.json();
    
    // Canvas Setup
    const container = document.getElementById('lattice-container');
    const canvas = document.getElementById('lattice-canvas');
    const ctx = canvas.getContext('2d');
    const ui = {
      card: document.getElementById('node-card'),
      title: document.getElementById('card-title'),
      count: document.getElementById('card-count'),
      list: document.getElementById('articles-list'),
      loader: document.getElementById('loading-overlay'),
      input: document.getElementById('node-search')
    };

    let width = container.clientWidth;
    let height = container.clientHeight;
    
    function resize() {
      width = container.clientWidth;
      height = container.clientHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', () => {
      resize();
      simulation.alpha(0.3).restart();
    });
    resize();

    // Simulation Setup
    const nodes = data.nodes.map(d => ({...d}));
    const links = data.links.map(d => ({...d}));

    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id(d => d.id).distance(150))
      .force('charge', d3.forceManyBody().strength(-400))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collide', d3.forceCollide().radius(d => d.val + 20).iterations(2));

    let transform = d3.zoomIdentity;
    let hoverNode = null;
    let activeNode = null;

    const zoom = d3.zoom()
      .scaleExtent([CONFIG.minZoom, CONFIG.maxZoom])
      .on('zoom', (event) => {
        transform = event.transform;
        render();
      });
    d3.select(canvas).call(zoom);

    // Initial positioning - center on origin with no offset since simulation centers nodes
    d3.select(canvas)
      .call(zoom.transform, d3.zoomIdentity.scale(0.9));

    setTimeout(() => {
      ui.loader.classList.add('fade-out');
    }, 1000);

    function render() {
      ctx.clearRect(0, 0, width, height);
      ctx.save();
      ctx.translate(transform.x, transform.y);
      ctx.scale(transform.k, transform.k);

      // Draw Links
      links.forEach(link => {
        ctx.beginPath();
        ctx.moveTo(link.source.x, link.source.y);
        ctx.lineTo(link.target.x, link.target.y);
        ctx.strokeStyle = `rgba(30, 41, 59, ${link.value > 1 ? 0.15 : 0.05})`; // Dark lines
        ctx.lineWidth = link.value;
        ctx.stroke();
      });

      // Draw Nodes
      nodes.forEach(node => {
        const isHovered = hoverNode === node;
        const isActive = activeNode === node;
        const color = CONFIG.colors[node.group] || CONFIG.colors.concept;
        
        // Node Body
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.val, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = color;
        ctx.lineWidth = isHovered || isActive ? 3 : 1.5;
        ctx.fill();
        ctx.stroke();

        // Inner Dot (frequency indicator)
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.val * 0.2, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();

        // Label
        if (transform.k > 0.8 || isHovered || isActive || node.val > 20) {
          ctx.fillStyle = '#1e293b';
          ctx.font = `${isHovered || isActive ? '600' : '400'} 10px Inter`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          // Label inside if big enough, otherwise below
          if (node.val > 25) {
             // Inside? No, keep it clean below
          }
          ctx.fillText(node.title, node.x, node.y + node.val + 12);
        }
      });

      ctx.restore();
    }

    d3.timer(render);

    function findNode(x, y) {
      const tx = (x - transform.x) / transform.k;
      const ty = (y - transform.y) / transform.k;
      
      let closest = null;
      let minDist = Infinity;
      
      nodes.forEach(node => {
        const dx = tx - node.x;
        const dy = ty - node.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < node.val + 10 && dist < minDist) {
          closest = node;
          minDist = dist;
        }
      });
      return closest;
    }

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const node = findNode(e.clientX - rect.left, e.clientY - rect.top);
      
      if (node !== hoverNode) {
        hoverNode = node;
        canvas.style.cursor = node ? 'pointer' : (d3.event?.active ? 'grabbing' : 'grab');
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const node = findNode(e.clientX - rect.left, e.clientY - rect.top);
      
      if (node) {
        activeNode = node;
        showCard(node);
        
        d3.select(canvas).transition().duration(750)
          .call(zoom.transform, d3.zoomIdentity.translate(width/2 - node.x * transform.k, height/2 - node.y * transform.k).scale(transform.k));
      } else {
        // activeNode = null; 
        // Optional: Close card on background click? 
        // User might want to drag without closing.
        // Let's keep card open until explict close or new selection?
        // Or close if clicking empty space?
        if (!d3.event?.active) {
            activeNode = null;
            hideCard();
        }
      }
    });
    
    // Dragging
    const drag = d3.drag()
        .subject(event => findNode(event.sourceEvent.offsetX, event.sourceEvent.offsetY))
        .on('start', event => {
            if (!event.subject) return;
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        })
        .on('drag', event => {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        })
        .on('end', event => {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        });
    d3.select(canvas).call(drag);

    function showCard(node) {
      ui.title.innerText = node.title;
      ui.count.innerText = `${node.articles.length} Article${node.articles.length !== 1 ? 's' : ''}`;
      
      // Build List
      ui.list.innerHTML = node.articles.map(article => `
        <a href="${article.slug}" class="article-link">
          <h3>${article.title}</h3>
          <p>${article.excerpt || 'No summary available.'}</p>
        </a>
      `).join('');

      ui.card.classList.remove('hidden');
    }

    function hideCard() {
      ui.card.classList.add('hidden');
    }

    // Search
    ui.input.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      if (term.length < 2) return;
      const match = nodes.find(n => n.title.toLowerCase().includes(term));
      if (match) {
        activeNode = match;
        d3.select(canvas).transition().duration(750)
          .call(zoom.transform, d3.zoomIdentity.translate(width/2 - match.x * 2, height/2 - match.y * 2).scale(2));
        showCard(match);
      }
    });

    document.getElementById('reset-view').addEventListener('click', () => {
      d3.select(canvas).transition().duration(750)
        .call(zoom.transform, d3.zoomIdentity.translate(width/2, height/2).scale(0.8));
      activeNode = null;
      hideCard();
    });
  }

  initLattice();
</script>
